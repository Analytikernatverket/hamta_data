lyckade_branscher <- union(lyckade_branscher, kvarvarande)
hittade <- TRUE; break
}
} else if (!is.na(n)) {
del <- dela_upp_branschgrupp(kvarvarande, kom, oms_kod, max_rader, lyckade_branscher)
lyckade_branscher <- del$lyckade_branscher
if (del$hittade) hittade <- TRUE
}
}
}
if (!hittade) break
if (length(aktuell_bransch_lista) > 0)
aktuell_bransch_lista <- aktuell_bransch_lista %>% imap(~ .x) %>% set_names(map_chr(., ~ sprintf("%s-%s", min(.x), max(.x))))
}
}
if (visa_resultat_meddelanden_konsol) {
kommun_namn <- api_kommunnamn_fran_resultat(resultat, kom, "S√§teskommun")
antal <- api_summa_for_kom(resultat, kom)
message(glue("üèÅ {kommun_namn}: h√§mtade {scb_format(antal)} f√∂retag p√• {scb_sec(kommun_start)} sekunder"))
}
} # kommunloop
retur_df <- resultat %>% list_rbind()
if (visa_resultat_meddelanden_konsol) {
kommun_txt <- if (n_distinct(retur_df$`S√§teskommun`) > 1) "kommuner" else "kommun"
message(glue("üìä Totalt h√§mtades {scb_format(nrow(retur_df))} f√∂retag fr√•n {length(kommunkoder)} {kommun_txt} p√• {scb_sec(total_start)} sekunder"))
}
retur_df
}
scb_hamta_arbetsstallen <- function(
kommunkoder = NULL,               # kommunkoder f√∂r de kommuner man vill ha data f√∂r, en eller flera i en vektor, tex: c("2080", "2085")
grundfilter = list(),             # m√∂jlighet att skicka med fler variabler f√∂r filtrering, g√∂rs i form av en namngiven list, tex. list(list(Kategori="S√§tesKommun", Kod=list("2080")), ...)
anstallda = NULL,                 # default √§r NULL = alla anst√§llda-klasser - anv√§nd scb_kategorier_med_kodtabeller("arbetsstallen") f√∂r att se vilka v√§rden som finns
branscher = NULL,                 # default √§r NULL = alla branscher - anv√§nd scb_kategorier_med_kodtabeller("arbetsstallen") f√∂r att se vilka v√§rden som finns
vald_arbetsstallestatus = 1,      # default √§r 1 = √§r verksam (finns ocks√• 0 = har aldrig varit verksam och 9 = √§r ej l√§ngre verksam)
cert_thumb = scb_hamta_cert_thumb(),         # thumb fr√•n installerat certifikat, kan skickas med men beh√∂ver oftast inte g√∂ras
visa_meddelanden_konsol = FALSE,             # detaljerade meddelanden om vad som h√§nder
visa_resultat_meddelanden_konsol = TRUE,     # meddelanden om vad som laddats ned
visa_progress = TRUE                         # progress-bar f√∂r om man har flera kommuner
) {
total_start <- Sys.time()
library(tidyverse); library(glue)
base_url <- "https://privateapi.scb.se/nv0101/v1/sokpavar/api/"
rakna_url <- paste0(base_url, "ae/raknaarbetsstallen/")
hamta_url <- paste0(base_url, "ae/hamtaarbetsstallen/")
kategorier_url <- paste0(base_url, "ae/kategoriermedkodtabeller")
max_rader <- 2000
.api_calls <- new.env(); .api_calls$timestamps <- numeric(0)
total_kombinationer <- length(kommunkoder)
if (visa_progress) {
pb <- progress::progress_bar$new(total = total_kombinationer, format = ":current/:total [:bar] :percent :message", clear = FALSE)
} else {
pb <- list(tick = function(...) NULL)
}
# --- resultat
resultat <- list()
resultat_lagg_till <- local({
.res_idx <- 0L
function(df, label = NULL) {
if (is.null(df) || !nrow(df)) return(invisible(NULL))
.res_idx <<- .res_idx + 1L
resultat[[.res_idx]] <<- df
if (!is.null(label)) {
if (visa_meddelanden_konsol) message(sprintf("Lade till lista #%d (%s): %d rader", .res_idx, label, nrow(df)))
} else {
if (visa_meddelanden_konsol) message(sprintf("Lade till lista #%d: %d rader", .res_idx, nrow(df)))
}
invisible(NULL)
}
})
rakna <- function(payload) rakna_api(rakna_url, payload, cert_thumb, .api_calls, visa_progress, visa_meddelanden_konsol)
hamta <- function(payload) hamta_api(hamta_url, payload, cert_thumb, .api_calls, visa_progress, visa_meddelanden_konsol)
skapa_payload <- function(kom = NULL, anst = NULL, bransch = NULL) {
kat <- list()
if (!is.null(kom))     kat <- append(kat, list(list(Kategori = "Kommun",               Kod = list(kom))))
if (!is.null(anst))    kat <- append(kat, list(list(Kategori = "Anst√§llda",            Kod = as.list(anst))))
if (!is.null(bransch)) kat <- append(kat, list(list(Kategori = "2-siffrig bransch 1",  Kod = as.list(bransch))))
payload <- list(Arbetsst√§llestatus = vald_arbetsstallestatus, Kategorier = kat)
if (length(grundfilter) > 0) payload$variabler <- grundfilter
payload
}
hamta_kategorier <- function() {
if (visa_progress && visa_meddelanden_konsol) message("üìã H√§mtar tillg√§ngliga kategorier f√∂r automatisk uppdelning...")
resp <- httr::GET(url = kategorier_url, config = httr::config(sslcert = paste0(cert_info$store, "\\MY\\", cert_thumb), sslcerttype = "Schannel"))
if (resp$status_code != 200) stop("‚ùå Kunde inte h√§mta kategorier fr√•n API:t")
kategorier <- httr::content(resp, as = "parsed", encoding = "UTF-8")
anst_kategori <- NULL; bransch_kategori <- NULL
for (kat in kategorier) {
if ("anst√§llda" == tolower(kat$Id_Kategori_AE)) anst_kategori <- kat
if (grepl("2-siffrig bransch 1", tolower(kat$Id_Kategori_AE))) bransch_kategori <- kat
}
anst_koder <- anst_kategori$VardeLista %>% keep(~ is.list(.x) && !is.null(.x$Varde)) %>% map_chr(~ as.character(.x$Varde))
bransch_koder <- bransch_kategori$VardeLista %>% keep(~ is.list(.x) && !is.null(.x$Varde)) %>% map_chr(~ as.character(.x$Varde))
if (visa_progress && visa_meddelanden_konsol) message(sprintf("‚úÖ H√§mtade %d anst√§llda-grupper och %d branscher", length(anst_koder), length(bransch_koder)))
list(anst = anst_koder, bransch = bransch_koder)
}
auto_kategorier <- NULL
for (kom in kommunkoder %||% list(NULL)) {
kommun_start <- Sys.time()
pb$tick(tokens = list(message = kom))
if (visa_progress && visa_meddelanden_konsol) message(sprintf("üîç Kommun %s: startar h√§mtning", kom))
if (is.null(auto_kategorier)) auto_kategorier <- hamta_kategorier()
aktuell_anst     <- anstallda %||% auto_kategorier$anst
aktuell_bransch  <- branscher %||% auto_kategorier$bransch
# Kan vi h√§mta allt i kommunen direkt?
payload_kom <- skapa_payload(kom = kom)
n_kom <- rakna(payload_kom)
if (!is.na(n_kom) && n_kom <= max_rader) {
res <- hamta(payload_kom)
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
if (visa_resultat_meddelanden_konsol) {
kommun_namn <- api_kommunnamn_fran_resultat(resultat, kom, "Kommun") %||% kom
antal <- api_summa_for_kom(resultat, kom)
message(glue("üèÅ {kommun_namn}: h√§mtade {scb_format(antal)} arbetsst√§llen p√• {scb_sec(kommun_start)} sekunder"))
}
next
}
}
# Steg 1: f√∂rs√∂k per anst√§llda-grupper
aktuell_anst_lista <- map(seq_along(aktuell_anst), ~ aktuell_anst[.x:length(aktuell_anst)])
lyckade_anst <- character(0)
repeat {
hittade <- FALSE
aktuell_anst_lista <- map(aktuell_anst_lista, ~ setdiff(.x, lyckade_anst)) %>% keep(~ length(.x) > 0)
for (anst_grupp in aktuell_anst_lista) {
if (all(anst_grupp %in% lyckade_anst)) next
if (length(anst_grupp) == 2) {
for (anst_kod in anst_grupp) {
if (anst_kod %in% lyckade_anst) next
n <- rakna(skapa_payload(kom = kom, anst = anst_kod))
if (visa_meddelanden_konsol) message(glue("üî¢ anst-kod {anst_kod} ‚Üí {n} arbetsst√§llen\n"))
if (!is.na(n) && n <= max_rader) {
res <- hamta(skapa_payload(kom = kom, anst = anst_kod))
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
lyckade_anst <- union(lyckade_anst, anst_kod)
hittade <- TRUE; break
}
}
}
} else {
kvarvarande <- setdiff(anst_grupp, lyckade_anst)
if (!length(kvarvarande)) next
n <- rakna(skapa_payload(kom = kom, anst = kvarvarande))
if (visa_meddelanden_konsol) message(glue("R√§knar rader i uttag: {n} stycken.\n"))
if (!is.na(n) && n <= max_rader) {
res <- hamta(skapa_payload(kom = kom, anst = kvarvarande))
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
lyckade_anst <- union(lyckade_anst, kvarvarande)
hittade <- TRUE; break
}
}
}
}
if (!hittade) break
}
# Steg 2: bryt upp i branscher
koder_att_bryta_upp <- setdiff(aktuell_anst, lyckade_anst)
dela_upp_branschgrupp <- function(bransch_koder, kom, anst_kod, max_rader, lyckade_branscher) {
if (!length(bransch_koder)) return(list(lyckade_branscher = lyckade_branscher, hittade = FALSE))
n <- rakna(skapa_payload(kom = kom, anst = anst_kod, bransch = bransch_koder))
if (length(bransch_koder) == 1) {
if (visa_meddelanden_konsol) message(glue("üî¢ anst {anst_kod} + Bransch {bransch_koder} ‚Üí {n} arbetsst√§llen\n"))
} else {
if (visa_meddelanden_konsol) message(glue("üî¢ anst {anst_kod} + Branscher {min(bransch_koder)}-{max(bransch_koder)} ‚Üí {n} arbetsst√§llen\n"))
}
if (!is.na(n) && n <= max_rader) {
res <- hamta(skapa_payload(kom = kom, anst = anst_kod, bransch = bransch_koder))
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
lyckade_branscher <- union(lyckade_branscher, bransch_koder)
return(list(lyckade_branscher = lyckade_branscher, hittade = TRUE))
}
} else if (!is.na(n) && n > max_rader && length(bransch_koder) > 1) {
if (visa_meddelanden_konsol) message(glue("Gruppen √§r f√∂r stor ({n} rader), delar upp...\n"))
mitt <- ceiling(length(bransch_koder) / 2)
r1 <- dela_upp_branschgrupp(bransch_koder[1:mitt], kom, anst_kod, max_rader, lyckade_branscher)
r2 <- dela_upp_branschgrupp(bransch_koder[(mitt+1):length(bransch_koder)], kom, anst_kod, max_rader, r1$lyckade_branscher)
return(list(lyckade_branscher = r2$lyckade_branscher, hittade = r1$hittade || r2$hittade))
}
list(lyckade_branscher = lyckade_branscher, hittade = FALSE)
}
for (anst_kod in koder_att_bryta_upp) {
if (visa_meddelanden_konsol) message(glue("\nüîç Delar upp anst-kod {anst_kod} i branscher...\n"))
bransch_grupper <- split(aktuell_bransch, cut(seq_along(aktuell_bransch), breaks = 5, labels = FALSE))
aktuell_bransch_lista <- map(seq_along(bransch_grupper), function(i) flatten_chr(bransch_grupper[i:length(bransch_grupper)])) %>%
set_names(map_chr(seq_along(bransch_grupper), function(i) { alla <- flatten_chr(bransch_grupper[i:length(bransch_grupper)]); sprintf("%s-%s", min(alla), max(alla)) }))
lyckade_branscher <- character(0)
repeat {
hittade <- FALSE
aktuell_bransch_lista <- map(aktuell_bransch_lista, ~ setdiff(.x, lyckade_branscher)) %>% keep(~ length(.x) > 0)
for (namn in names(aktuell_bransch_lista)) {
kvarvarande <- setdiff(aktuell_bransch_lista[[namn]], lyckade_branscher)
if (!length(kvarvarande)) next
if (length(kvarvarande) == 2) {
for (br_kod in kvarvarande) {
n <- rakna(skapa_payload(kom = kom, anst = anst_kod, bransch = br_kod))
if (visa_meddelanden_konsol) message(glue("üî¢ anst {anst_kod} + Bransch {br_kod} ‚Üí {n} arbetsst√§llen\n"))
if (!is.na(n) && n <= max_rader) {
res <- hamta(skapa_payload(kom = kom, anst = anst_kod, bransch = br_kod))
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
lyckade_branscher <- union(lyckade_branscher, br_kod)
hittade <- TRUE; break
}
}
}
} else {
n <- rakna(skapa_payload(kom = kom, anst = anst_kod, bransch = kvarvarande))
if (!is.na(n) && n <= max_rader) {
res <- hamta(skapa_payload(kom = kom, anst = anst_kod, bransch = kvarvarande))
if (!is.null(res)) {
resultat_lagg_till(res %>% mutate(kod_kommun = kom), label = "kommun")
lyckade_branscher <- union(lyckade_branscher, kvarvarande)
hittade <- TRUE; break
}
} else if (!is.na(n)) {
del <- dela_upp_branschgrupp(kvarvarande, kom, anst_kod, max_rader, lyckade_branscher)
lyckade_branscher <- del$lyckade_branscher
if (del$hittade) hittade <- TRUE
}
}
}
if (!hittade) break
if (length(aktuell_bransch_lista) > 0)
aktuell_bransch_lista <- aktuell_bransch_lista %>% imap(~ .x) %>% set_names(map_chr(., ~ sprintf("%s-%s", min(.x), max(.x))))
}
}
if (visa_resultat_meddelanden_konsol) {
kommun_namn <- api_kommunnamn_fran_resultat(resultat, kom, "Kommun") %||% kom
antal <- api_summa_for_kom(resultat, kom)
message(glue("üèÅ {kommun_namn}: h√§mtade {scb_format(antal)} arbetsst√§llen p√• {scb_sec(kommun_start)} sekunder"))
}
} # kommunloop
retur_df <- resultat %>% list_rbind()
if (visa_resultat_meddelanden_konsol) {
kommun_txt <- if (n_distinct(retur_df$Kommun) > 1) "kommuner" else "kommun"
message(glue("üìä Totalt h√§mtades {scb_format(nrow(retur_df))} arbetsst√§llen fr√•n {length(kommunkoder)} {kommun_txt} p√• {scb_sec(total_start)} sekunder"))
}
retur_df
}
scb_rakna_foretag_i_kommuner("1489")
# ===== ftg_arbst_api_scb_func.R =====
# f√∂r att kunna anv√§nda detta skript m√•ste ett certifikat fr√•n SCB
# f√∂rst installeras p√• datorn. Certifikatet f√•r man fr√•n SCB om man
# ber om det, kontaktuppgifter finns h√§r:
# https://www.scb.se/vara-tjanster/bestall-data-och-statistik/foretagsregistret/avgiftsfria-uppgifter-i-foretagsregistret/#fatillgang
# Dessa skript best√•r av tv√• filer:
# 1. ftg_arbst_api_scb_func.R (denna fil)
# 2. ftg_arbst_api_scb.R
# Den senare filen source:ar in den f√∂rsta s√• det r√§cker att k√∂ra en source p√• den andra
# Principen i denna funktionsfil √§r att det funktioner som b√∂rjar p√• "scb_"
# kan man anv√§nda, √∂vriga funktioner anv√§nds av skripten.
# Det √§r v√§lkommet att f√∂rb√§ttra skripten, men se g√§rna till att de √§r bak√•t-
# kompatibla. SCB har aviserat att API:et ska ers√§ttas av ett rimligare s√•
# l√§gg inte alltf√∂r mycket tid p√• att f√∂rb√§ttra detta skript. =)
# Peter M√∂ller, Region Dalarna, augusti 2025
suppressPackageStartupMessages({
library(httr)
library(jsonlite)
library(glue)
library(tidyverse)
})
# h√§mtar lokalisering f√∂r certifikatet, som kan ligga p√• LocalMachine
# eller CurrentUser
scb_hamta_cert <- function() {
parse_store <- function(cmd, store) {
rr <- try(system(cmd, intern = TRUE), silent = TRUE)
if (inherits(rr, "try-error")) return(NULL)
r <- iconv(rr, from = "windows-1252", to = "UTF-8")
df <- tibble(rad = r) |>
tidyr::fill(rad, .direction = "down") |>
mutate(
subject = if_else(grepl("^Subject:", rad), sub(".*CN=", "", rad), NA_character_),
issuer  = if_else(grepl("^Issuer:",  rad), sub("^Issuer: ", "", rad), NA_character_),
thumb   = if_else(grepl("^Cert Hash(.*):", rad), gsub(".*: ", "", rad), NA_character_)
) |>
tidyr::fill(subject, issuer) |>
filter(!is.na(thumb)) |>
mutate(subject_lc = tolower(subject), issuer_lc = tolower(issuer)) |>
# matcha: CN inneh√•ller sokpavar/s√∂kp√•ver ELLER issuer inneh√•ller scb
filter(grepl("sokpavar|s√∂kp√•ver|sokp√•ver", subject_lc) | grepl("\\bscb\\b", issuer_lc)) |>
transmute(store = store, thumb = gsub(" ", "", thumb))
if (nrow(df)) df[1,] else NULL
}
hit <- parse_store("certutil -user -store My", "CurrentUser")
if (is.null(hit)) hit <- parse_store("certutil -store My",      "LocalMachine")
if (is.null(hit)) stop("Hittade inget SCB-s√∂kp√•ver-cert i CurrentUser eller LocalMachine.")
list(store = hit$store, thumb = hit$thumb)
}
# global variabel som anv√§nds ist√§llet f√∂r att alltid k√∂ra funktionen vid varje postning
cert_info <- scb_hamta_cert()
# H√§mta certifikat-thumbprint (Windows, certutil)
scb_hamta_cert_thumb <- function() {
cert_rader_raw <- tryCatch(system("certutil -user -store My", intern = TRUE), error = function(e) character())
cert_local     <- tryCatch(system("certutil -store My", intern = TRUE),      error = function(e) character())
cert_rader_raw_alla <- c(cert_rader_raw, cert_local)
if (!length(cert_rader_raw_alla)) stop("Kunde inte l√§sa certifikat fr√•n certutil.")
cert_rader <- iconv(cert_rader_raw_alla, from = "windows-1252", to = "UTF-8")
cert_df <- tibble(rad = cert_rader) %>%
fill(rad, .direction = "down") %>%
mutate(
cert_namn = if_else(grepl("^Subject:", rad), gsub(".*CN=", "", rad), NA_character_),
thumb     = if_else(grepl("^Cert Hash(.*):", rad), gsub(".*: ", "", rad), NA_character_)
) %>%
fill(cert_namn) %>%
filter(!is.na(thumb)) %>%
select(cert_namn, thumb) %>%
filter(str_detect(tolower(cert_namn), "scb"), str_detect(tolower(cert_namn), "sokpavar"))
if (!nrow(cert_df)) stop("Hittade inget SCB-s√∂kp√•ver-certifikat i Windows certifikatf√∂rr√•d.")
cert_df$thumb[[1]]
}
# Rate-limitad POST mot API:t (max ~10 anrop per 10s)
api_posta <- function(url, body, cert_thumb, .api_calls_env, visa_progress = TRUE, visa_medd = TRUE) {
now <- as.numeric(Sys.time())
.api_calls_env$timestamps <- .api_calls_env$timestamps[.api_calls_env$timestamps > now - 10]
if (length(.api_calls_env$timestamps) >= 10) {
wait_time <- 10 - (now - min(.api_calls_env$timestamps))
if (visa_progress && visa_medd) message(sprintf("‚è≥ V√§ntar %.1f sek pga anropsgr√§ns...", wait_time))
Sys.sleep(wait_time)
}
.api_calls_env$timestamps <- c(.api_calls_env$timestamps, as.numeric(Sys.time()))
httr::POST(
url,
add_headers(`Content-Type`="application/json", Accept="application/json"),
body   = jsonlite::toJSON(body, auto_unbox = TRUE),
encode = "json",
httr::config(sslcert = paste0(cert_info$store, "\\MY\\", cert_thumb), sslcerttype = "Schannel")
)
}
# Generisk rakna()-hj√§lpare
rakna_api <- function(rakna_url, payload, cert_thumb, .api_calls_env, visa_progress = TRUE, visa_medd = TRUE) {
r <- api_posta(rakna_url, payload, cert_thumb, .api_calls_env, visa_progress, visa_medd)
if (r$status_code != 200) return(NA)
httr::content(r)
}
# Generisk hamta()-hj√§lpare (returnerar tibble eller NULL)
hamta_api <- function(hamta_url, payload, cert_thumb, .api_calls_env, visa_progress = TRUE, visa_medd = TRUE) {
r <- api_posta(hamta_url, payload, cert_thumb, .api_calls_env, visa_progress, visa_medd)
if (r$status_code != 200) return(NULL)
innehall <- httr::content(r, simplifyVector = TRUE)
if (is.null(innehall)) return(NULL)
if (is.data.frame(innehall)) {
as_tibble(innehall)
} else if (is.list(innehall) && length(innehall) > 0 && is.data.frame(innehall[[1]])) {
as_tibble(innehall[[1]])
} else {
NULL
}
}
# S√§ker appender som inte skriver √∂ver och ger index + logg
skapa_resultat_lagg_till <- function(resultat_ref, visa_medd = TRUE) {
.res_idx <- 0L
force(resultat_ref)
function(df, label = NULL) {
if (is.null(df) || !nrow(df)) return(invisible(NULL))
.res_idx <<- .res_idx + 1L
resultat_ref[[.res_idx]] <<- df
if (visa_medd) {
if (is.null(label)) {
message(sprintf("Lade till lista #%d: %d rader", .res_idx, nrow(df)))
} else {
message(sprintf("Lade till lista #%d (%s): %d rader", .res_idx, label, nrow(df)))
}
}
invisible(NULL)
}
}
# Hj√§lpare: formatering
scb_format <- function(x) format(x, big.mark = " ", scientific = FALSE, trim = TRUE)
scb_sec <- function(start_time) round(as.numeric(difftime(Sys.time(), start_time, units = "secs")), 1)
# H√§mta kommunnamn ur resultat (f√∂rsta f√∂rekomsten)
api_kommunnamn_fran_resultat <- function(resultat_lista, kom, kolumn_namn) {
out <- resultat_lista %>%
keep(~ !is.null(.x) && "kod_kommun" %in% names(.x) && any(.x$kod_kommun == kom)) %>%
pluck(1)
if (is.null(out) || !nrow(out) || !(kolumn_namn %in% names(out))) return(kom)
val <- out %>% filter(kod_kommun == kom) %>% slice(1) %>% dplyr::pull(all_of(kolumn_namn))
val %||% kom
}
# Summera antal rader i resultat f√∂r given kommunkod
api_summa_for_kom <- function(resultat_lista, kom) {
if (is.null(resultat_lista)) return(0L)
sum(purrr::map_int(resultat_lista, ~ if (!is.null(.x) && "kod_kommun" %in% names(.x) && any(.x$kod_kommun == kom)) nrow(.x) else 0L))
}
# ---- H√§mta KategorierMedKodtabeller (Je/Ae) och g√∂r tibble ----
scb_kategorier_med_kodtabeller <- function(
tabell = "foretag",         # "foretag"  eller "arbetsstalle"
med_varden = TRUE,          # TRUE = variabler med v√§rden, FALSE = bara variabler
cert_thumb = scb_hamta_cert_thumb()) {
del <- if_else(tolower(tabell) %in% c("ftg", "foretag", "f√∂retag"), "Je", "Ae")
base_url <- "https://privateapi.scb.se/nv0101/v1/sokpavar/api/"
url <- paste0(base_url, del, "/KategorierMedKodtabeller")
r <- GET(url,
config = config(sslcert = paste0(cert_info$store, "\\MY\\", cert_thumb),
sslcerttype = "Schannel"))
stop_for_status(r)
kats <- content(r, as = "parsed", encoding = "UTF-8")
# Platta ut: en rad per (kategori, kod)
retur_df <- tibble(
kategori_id = map_chr(kats, ~ .x$Id_Kategori_JE %||% .x$Id_Kategori_AE %||% .x$Id_Kategori %||% .x$Id),
kategori_typ = map_chr(kats, ~ .x$Datatyp %||% NA_character_),
varde_lista = map(kats, ~ .x$VardeLista %||% list())
) |>
mutate(varde_lista = map(varde_lista, ~ keep(.x, ~ is.list(.x) && (!is.null(.x$Varde) || !is.null(.x$Kod)))) ) |>
unnest_longer(varde_lista, keep_empty = TRUE) |>
mutate(
kod  = map_chr(varde_lista, ~ as.character(.x$Varde %||% .x$Kod %||% NA_character_)),
text = map_chr(varde_lista, ~ as.character(.x$Text  %||% .x$Beskrivning %||% NA_character_))
) |>
select(-varde_lista)
if (!med_varden) {
retur_df <- retur_df %>%
group_by(kategori_id) %>%
summarise(antal_unika_varden = n(), .groups = "drop")
}
return(retur_df)
}
# # ---- Exempel ----
# # Alla kategorier f√∂r f√∂retag med kodtabeller
# ftg_kat_varden <- scb_kategorier_med_kodtabeller("foretag")
# ftg_bara_kat <- scb_kategorier_med_kodtabeller("foretag", med_varden = FALSE)
# # Alla kategorier f√∂r arbetsst√§llen med kodtabeller
# arbst_kat_varden <- scb_kategorier_med_kodtabeller("arbetsstalle")
# arbst_bara_kat <- scb_kategorier_med_kodtabeller("arbetsstalle", med_varden = FALSE)
# # Titta p√• en kategori:
# je_kat |> filter(kategori_id == "Juridisk form") |> select(kategori_id, kod, text) |> distinct()
# Bygg payload av bas-kategorier + extra kategorier och valfria statusf√§lt
api_bygg_payload <- function(
kategori_lista,           # list(list(Kategori="S√§tesKommun", Kod=list("2080")), ...)
foretagsstatus = NULL,    # t.ex. "1" eller c("0","1","9") eller NULL
regstatus = NULL,         # t.ex. "1" eller c("1","9") eller NULL
arbetsstallestatus = NULL,# t.ex. "1" eller NULL
extra_kategorier = NULL   # samma struktur som kategori_lista
){
kat <- kategori_lista
if (!is.null(extra_kategorier) && length(extra_kategorier)) {
kat <- c(kat, extra_kategorier)
}
payload <- list(Kategorier = kat)
if (!is.null(foretagsstatus))      payload$F√∂retagsstatus      <- unname(foretagsstatus)
if (!is.null(regstatus))           payload$Registreringsstatus <- unname(regstatus)
if (!is.null(arbetsstallestatus))  payload$Arbetsst√§llestatus  <- unname(arbetsstallestatus)
payload
}
scb_rakna_foretag_i_kommuner <- function(
kommunkoder,
foretagsstatus = "1",                # NULL = alla; eller vektor c("0","1","9")
registreringsstatus = "1",          # NULL = alla; eller vektor c("1","9")
extra_kategorier = NULL,            # t.ex. list(list(Kategori="2-siffrig bransch 1", Kod=c("10","11")))
cert_thumb = scb_hamta_cert_thumb(),
returnera_till_konsol = TRUE,
returnera_df = FALSE
){
source("https://raw.githubusercontent.com/Region-Dalarna/funktioner/main/func_API.R", encoding = "utf-8", echo = FALSE)
base_url  <- "https://privateapi.scb.se/nv0101/v1/sokpavar/api/"
rakna_url <- paste0(base_url, "je/raknaforetag/")
.api_calls <- new.env(); .api_calls$timestamps <- numeric(0)
retur_df <- map_dfr(kommunkoder, function(kom){
payload <- api_bygg_payload(
kategori_lista = list(list(Kategori = "S√§tesKommun", Kod = list(kom))),
foretagsstatus = foretagsstatus,
regstatus      = registreringsstatus,
extra_kategorier = extra_kategorier
)
n <- rakna_api(rakna_url, payload, cert_thumb, .api_calls, visa_medd, visa_medd)
kommun_namn <- hamtaregion_kod_namn(kom)$region
if (returnera_till_konsol) message(glue::glue("üìè {kommun_namn}: {n %||% NA} f√∂retag"))
tibble(kommun = kom, antal_foretag = as.integer(n %||% NA))
})
if (returnera_df) return(retur_df)
}
scb_rakna_arbetsstallen_i_kommuner <- function(
kommunkoder,
arbetsstallestatus = "1",           # NULL = alla; eller vektor
extra_kategorier = NULL,            # t.ex. list(list(Kategori="2-siffrig bransch 1", Kod=c("10","11")))
cert_thumb = scb_hamta_cert_thumb(),
returnera_till_konsol = TRUE,
returnera_df = FALSE
){
source("https://raw.githubusercontent.com/Region-Dalarna/funktioner/main/func_API.R", encoding = "utf-8", echo = FALSE)
base_url  <- "https://privateapi.scb.se/nv0101/v1/sokpavar/api/"
rakna_url <- paste0(base_url, "ae/raknaarbetsstallen/")
.api_calls <- new.env(); .api_calls$timestamps <- numeric(0)
retur_df <- map_dfr(kommunkoder, function(kom){
payload <- api_bygg_payload(
kategori_lista = list(list(Kategori = "Kommun", Kod = list(kom))),
arbetsstallestatus = arbetsstallestatus,
extra_kategorier = extra_kategorier
)
n <- rakna_api(rakna_url, payload, cert_thumb, .api_calls, visa_medd, visa_medd)
kommun_namn <- hamtaregion_kod_namn(kom)$region
if (returnera_till_konsol) message(glue::glue("üìè {kommun_namn}: {n %||% NA} arbetsst√§llen"))
tibble(kommun = kom, antal_arbetsstallen = as.integer(n %||% NA))
})
if (returnera_df) return(retur_df)
}
scb_rakna_foretag_i_kommuner("1489")
scb_rakna_foretag_i_kommuner("1489")
test <- -scb_hamta_foretag("1443")
test <- scb_hamta_foretag("1443")
scb_hamta_arbetsstallen("1488")
test <- scb_hamta_foretag("1283")
test <- scb_hamta_foretag("1283", visa_meddelanden_konsol = TRUE)
test2 <- scb_hamta_foretag("1283", visa_meddelanden_konsol = TRUE, juridisk_kod = NULL)
View(test2)
gh_dia("prog")
gh_dia("prog&totalt")
source("https://raw.githubusercontent.com/Region-Dalarna/diagram/main/diag_bef_utfall_prognos_per_region_totalt_scb.R")
View(diag_bef_utfall_prognos_per_region_totalt)
diag_bef_utfall_prognos_per_region_totalt(region_vekt = "2083", skriv_till_excelfil = TRUE)
